climate:
  - platform: thermostat
    name: "${friendly_name}"
    id: smart_thermostat
    sensor: compensated_temperature
    web_server:
      sorting_group_id: group_climate

    visual:
      min_temperature: 15 °C
      max_temperature: 30 °C
      temperature_step: 0.1 °C

    default_preset: Home
    preset:
      - name: Home
        default_target_temperature_low: ${default_heat_setpoint} °C
        default_target_temperature_high: ${default_cool_setpoint} °C
      - name: Away
        default_target_temperature_low: 18 °C
        default_target_temperature_high: 27 °C
      - name: Sleep
        default_target_temperature_low: 19 °C
        default_target_temperature_high: 25 °C
      - name: Boost
        default_target_temperature_low: 22 °C
        default_target_temperature_high: 23 °C

 
    min_idle_time: 10s
    min_heating_run_time: 10s
    min_cooling_run_time: 10s
    min_cooling_off_time: 10s
    min_heating_off_time: 10s
    min_fanning_off_time: 10s
    min_fanning_run_time: 10s
    min_fan_mode_switching_time: 10s


    heat_deadband: ${temp_deadband} °C
    cool_deadband: ${temp_deadband} °C

    # Heat Action - Intelligent Dual Stage
    heat_action:
      - if:
          condition:
            lambda: 'return id(boot_lockout);'
          then:
            - lambda: |-
                ESP_LOGW("hvac", "Heating requested but boot lockout active - waiting...");
            - wait_until:
                lambda: 'return !id(boot_lockout);'
      # Reboot protection: Respect minimum heating off time
      - if:
          condition:
            lambda: |-
              if (id(last_heat_off_time_persistent) == 0) return false;
              unsigned long min_off_ms = id(min_heat_run_minutes).state * 60 * 1000;
              unsigned long elapsed = millis() - id(last_heat_off_time_persistent);
              return elapsed < min_off_ms;
          then:
            - lambda: |-
                unsigned long min_off_ms = id(min_heat_run_minutes).state * 60 * 1000;
                unsigned long elapsed = millis() - id(last_heat_off_time_persistent);
                unsigned long remaining_ms = min_off_ms - elapsed;
                ESP_LOGW("hvac", "Reboot protection: Heating off for only %.1f min, waiting %.1f min more",
                         elapsed / 60000.0, remaining_ms / 60000.0);
            - wait_until:
                condition:
                  lambda: |-
                    unsigned long min_off_ms = id(min_heat_run_minutes).state * 60 * 1000;
                    unsigned long elapsed = millis() - id(last_heat_off_time_persistent);
                    return elapsed >= min_off_ms;
            - lambda: |-
                ESP_LOGI("hvac", "Reboot protection: Minimum heating off time elapsed");
      - if:
          condition:
            lambda: 'return id(cool_relay).state || id(fan_relay).state && id(last_hvac_mode) == 2;'
          then:
            - lambda: |-
                ESP_LOGD("hvac", "Interlock: Waiting for cooling/fan to finish");
            - wait_until:
                lambda: 'return !id(cool_relay).state && !id(fan_relay).state;'
      - lambda: |-
          id(last_hvac_mode) = 1;
          ESP_LOGI("hvac", "Heat stage 1 starting");
      - switch.turn_on: heat_stage1_relay
      - switch.turn_on: fan_relay
      - lambda: 'id(heat_stage1_start_time) = millis();'
      # STAGE 2: Stage 2 delay and engagement - Comment out the following lines to disable stage 2
      - wait_until:
          timeout: !lambda "return id(stage2_delay_minutes).state * 60 * 1000;"
          condition: {lambda: 'return id(smart_thermostat).action == CLIMATE_ACTION_IDLE;'}
      - if:
          condition:
            lambda: |-
              bool still_heating = id(smart_thermostat).action == CLIMATE_ACTION_HEATING;
              bool should_engage = id(stage2_should_engage).state;

              if (still_heating && !should_engage) {
                ESP_LOGW("hvac", "Stage 2 delay elapsed but inhibited by Home Assistant logic");
              }

              return still_heating && should_engage;
          then:
            - lambda: |-
                ESP_LOGI("hvac", "Engaging heat stage 2");
            - switch.turn_on: heat_stage2_relay

    # Cool Action
    cool_action:

      - if:
          condition:
            lambda: 'return id(boot_lockout);'
          then:
            - lambda: |-
                ESP_LOGW("hvac", "Cooling requested but boot lockout active - waiting...");
            - wait_until:
                lambda: 'return !id(boot_lockout);'
      # Reboot protection: Respect minimum cooling off time
      - if:
          condition:
            lambda: |-
              if (id(last_cool_off_time_persistent) == 0) return false;
              unsigned long min_off_ms = id(min_compressor_off_minutes).state * 60 * 1000;
              unsigned long elapsed = millis() - id(last_cool_off_time_persistent);
              return elapsed < min_off_ms;
          then:
            - lambda: |-
                unsigned long min_off_ms = id(min_compressor_off_minutes).state * 60 * 1000;
                unsigned long elapsed = millis() - id(last_cool_off_time_persistent);
                unsigned long remaining_ms = min_off_ms - elapsed;
                ESP_LOGW("hvac", "Reboot protection: Compressor off for only %.1f min, waiting %.1f min more",
                         elapsed / 60000.0, remaining_ms / 60000.0);
            - wait_until:
                condition:
                  lambda: |-
                    unsigned long min_off_ms = id(min_compressor_off_minutes).state * 60 * 1000;
                    unsigned long elapsed = millis() - id(last_cool_off_time_persistent);
                    return elapsed >= min_off_ms;
            - lambda: |-
                ESP_LOGI("hvac", "Reboot protection: Minimum compressor off time elapsed");
      - if:
          condition:
            lambda: 'return id(heat_stage1_relay).state || id(fan_relay).state && id(last_hvac_mode) == 1;'
          then:
            - lambda: |-
                ESP_LOGD("hvac", "Interlock: Waiting for heating/fan to finish");
            - wait_until:
                lambda: 'return !id(heat_stage1_relay).state && !id(fan_relay).state;'

      # COMPRESSOR LOCKOUT: Only start timer if compressor is currently OFF
      - if:
          condition:
            lambda: 'return !id(cool_relay).state;'
          then:
            - lambda: |-
                ESP_LOGD("hvac", "Cooling requested - checking compressor lockout");
            - wait_until:
                condition:
                  lambda: |-
                    unsigned long lockout_ms = id(min_compressor_off_minutes).state * 60 * 1000;
                    if (id(last_compressor_stop_time) == 0) return true;
                    return (millis() - id(last_compressor_stop_time) >= lockout_ms);
            - lambda: |-
                ESP_LOGI("hvac", "Lockout cleared - engaging compressor");

      - lambda: |-
          id(last_hvac_mode) = 2;
          ESP_LOGI("hvac", "Cooling mode starting");
      - switch.turn_on: cool_relay
      - switch.turn_on: fan_relay
      - lambda: 'id(cool_start_time) = millis();'

    # Idle Action - supports heat/cool run/off times
    idle_action:
      - lambda: |-
          ESP_LOGD("hvac", "Target reached - checking minimum runtime safety");
      - wait_until:
          condition:
            lambda: |-
              unsigned long now = millis();
              unsigned long min_heat_ms = id(min_heat_run_minutes).state * 60 * 1000;
              unsigned long min_cool_ms = id(min_cool_run_minutes).state * 60 * 1000;

              bool heat_ok = (id(heat_stage1_start_time) == 0) || (now - id(heat_stage1_start_time) >= min_heat_ms);
              bool cool_ok = (id(cool_start_time) == 0) || (now - id(cool_start_time) >= min_cool_ms);

              return heat_ok && cool_ok;
      - lambda: |-
          ESP_LOGI("hvac", "Min runtimes met - entering idle mode");
      - switch.turn_off: heat_stage1_relay
      - switch.turn_off: heat_stage2_relay  # STAGE 2: Comment out this line if stage 2 disabled
      - switch.turn_off: cool_relay
      - lambda: |-
          unsigned long now = millis();
          id(heat_stage1_start_time) = 0;
          id(cool_start_time) = 0;
          id(last_compressor_stop_time) = now;

          // Save off times persistently for reboot protection
          if (id(last_hvac_mode) == 1) {
            id(last_heat_off_time_persistent) = now;
            ESP_LOGI("hvac", "Heating turned off - saved for reboot protection");
          } else if (id(last_hvac_mode) == 2) {
            id(last_cool_off_time_persistent) = now;
            ESP_LOGI("hvac", "Cooling turned off - saved for reboot protection");
          }
      - delay: !lambda |-
          // Determine which post-run delay to use based on what was running
          int delay_seconds = 30; // Default fallback

          // Check last HVAC mode (1=heating, 2=cooling)
          if (id(last_hvac_mode) == 2) {
            delay_seconds = (int)id(fan_post_run_cool_seconds).state;
            ESP_LOGD("fan", "Using cooling post-run delay: %d seconds", delay_seconds);
          } else if (id(last_hvac_mode) == 1) {
            delay_seconds = (int)id(fan_post_run_heat_seconds).state;
            ESP_LOGD("fan", "Using heating post-run delay: %d seconds", delay_seconds);
          }

          // Reset mode tracker
          id(last_hvac_mode) = 0;

          return delay_seconds * 1000; // Return milliseconds
      - lambda: |-
          ESP_LOGD("fan", "Post-run delay complete - fan off");
      - switch.turn_off: fan_relay

#fan mode - on
    fan_mode_on_action:
      - lambda: |-
          ESP_LOGI("hvac", "Fan mode: ON");
      - switch.turn_on: fan_relay

# Fan mode - off
    fan_mode_off_action:
      - lambda: |-
          ESP_LOGI("hvac", "Fan mode: OFF");
      - switch.turn_off: fan_relay

# Fan mode - auto
    fan_mode_auto_action:
      - lambda: |-
          ESP_LOGI("hvac", "Fan mode: AUTO");

#fan only running relay modes
    fan_only_action:
      - lambda: |-
          ESP_LOGI("hvac", "Fan only mode activated");
      - switch.turn_on: fan_relay
      - switch.turn_off: heat_stage1_relay
      - switch.turn_off: heat_stage2_relay  # STAGE 2: Comment out this line if stage 2 disabled
      - switch.turn_off: cool_relay

# Number inputs for tuning

# Stage 2 heat start delay
